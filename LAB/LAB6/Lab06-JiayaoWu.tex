\documentclass[12pt,a4paper]{article}
%\usepackage{ctex}
\usepackage{amsmath,amscd,amsbsy,amssymb,latexsym,url,bm,amsthm}
\usepackage{epsfig,graphicx,subfigure}
\usepackage{enumitem,balance}
\usepackage{wrapfig}
\usepackage{mathrsfs,euscript}
\usepackage[x11names,svgnames,dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage[vlined,ruled,commentsnumbered,linesnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{multicol}
%\usepackage{fontspec}

\renewcommand{\listalgorithmcfname}{List of Algorithms}
\renewcommand{\algorithmcfname}{Alg}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{exercise}{Exercise}
\newtheorem*{solution}{Solution}
\newtheorem{definition}{Definition}
\theoremstyle{definition}


%\numberwithin{equation}{section}
%\numberwithin{figure}{section}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand{\postscript}[2]
 {\setlength{\epsfxsize}{#2\hsize}
  \centerline{\epsfbox{#1}}}

\renewcommand{\baselinestretch}{1.0}

\setlength{\oddsidemargin}{-0.365in}
\setlength{\evensidemargin}{-0.365in}
\setlength{\topmargin}{-0.3in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{10.1in}
\setlength{\textwidth}{7in}
\makeatletter \renewenvironment{proof}[1][Proof] {\par\pushQED{\qed}\normalfont\topsep6\p@\@plus6\p@\relax\trivlist\item[\hskip\labelsep\bfseries#1\@addpunct{.}]\ignorespaces}{\popQED\endtrivlist\@endpefalse} \makeatother
\makeatletter
\renewenvironment{solution}[1][Solution] {\par\pushQED{\qed}\normalfont\topsep6\p@\@plus6\p@\relax\trivlist\item[\hskip\labelsep\bfseries#1\@addpunct{.}]\ignorespaces}{\popQED\endtrivlist\@endpefalse} \makeatother


\definecolor{codegreen}{rgb}{0.44,0.68,0.28}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstset{
language=C++,
frame=shadowbox,
keywordstyle = \color{blue}\bfseries,
commentstyle=\color{codegreen},
tabsize = 4,
backgroundcolor=\color{backcolour},
numbers=left,
numbersep=5pt,
breaklines=true,
emph = {int,float,double,char},emphstyle=\color{orange},
emph ={[2]const, typedef},emphstyle = {[2]\color{red}} }



\begin{document}
\noindent

%========================================================================
\noindent\framebox[\linewidth]{\shortstack[c]{
\Large{\textbf{Lab06-Heaps and BST}}\vspace{1mm}\\
VE281 - Data Structures and Algorithms, Xiaofeng Gao, TA: Li Ma, Autumn 2019}}
%CS26019 - Algorithm Design and Analysis, Xiaofeng Gao, Autumn 2019}}
\begin{center}
\footnotesize{\color{red}$*$ Please upload your assignment to website. Contact webmaster for any questions.}

\footnotesize{\color{blue}$*$ Name:Wu Jiayao  \quad Student ID:517370910257 \quad Email: jiayaowu1999@sjtu.edu.cn}
\end{center}


\begin{enumerate}

\item \textbf{D-ary Heap.} D-ary heap is similar to binary heapï¼Œbut (with one possible exception) each non-leaf node of d-ary heap has $d$ children, not just $2$ children.

\begin{enumerate}
\item How to represent a d-ary heap in an array?
\item What is the height of the d-ary heap with $n$ elements? Please use $n$ and $d$ to show.
\item Please give the implementation of insertion on the min heap of d-ary heap, and show the time complexity with $n$ and $d$.
\end{enumerate}

\begin{lstlisting}[language=C++]
// Input: an integer k
// Output: null
void enqueue(int k)
{
	// TODO;
}
\end{lstlisting}

\begin{solution}
    $\ $ 
	\begin{enumerate}
	    \item The root is the first element in the array. The $i^{th}$ child of node $x$ in the tree is the $(x\cdot d+i)^{th}$ element in the array. The parent of node $x$ is $\lfloor (x-1)/d \rfloor^{th} $ element in the array.
	    \item Suppose the height of the heap is $h$. The maximum number of nodes at level $k(0\leq k\leq h)$ is $d^k$ . Hence, the number of nodes $n$ at height $h$ meets that
\begin{equation*}
	\begin{split}
	\sum_{k=0}^{h-1}d^k <\  &n\ \leq \sum_{k=0}^{h}d^k\\
	\frac{d^h-1}{d-1} < \ &n\ \leq\frac{d^{h+1}-1}{d-1}\\
	\end{split}
\end{equation*}
The height of the d-ary heap with $n$ elements is
$$
	h=\lceil\log_d(nd-n+1)-1\rceil
$$
	    \item Since the worst case happens i reaches 1 or 0, the total loop times is $\mathcal{O}(\log_dn)$,which is the time complexity.
\begin{lstlisting}[language=C++]
// Input: an integer k
// Output: null
void enqueue(int k)
{
	// TODO;
	array[n++]=k;
	int i = n;
	while(i > 0 && array[i] < array[(i-1)/d] )
	{
        int tmp = array[i];
        array[i] = array[(i-1)/d];
        array[(i-1)/d] = tmp;
        i = (i-1)/d;
	}
}
\end{lstlisting}
	\end{enumerate}
\end{solution}

\item \textbf{Median Maintenance.} Input a sequence of numbers $x_1,x_2...,x_n$, one-by-one. At each time step $i$, output the median of $x_1,x_2...,x_i$. How to do this with $O(\log i)$ time at each step $i$? Show the implementation.

\begin{solution}
\begin{lstlisting}
void get_median()
{

    priority_queue<double, std::vector<double>, std::less<double>> max_heap;
    priority_queue<double, std::vector<double>, std::greater<double>> min_heap;
    int counter = 0;
    while(true)
    {
        string str;
        cin >> str;
        if(str == "exit")
        {
            break;
        }
        stringstream ss;
        ss << str;
        double p = 0;
        ss >> p;
        double median = 0;
        //Suppose max heap >= min heap in numbers
        if (counter == 0)
        {
            max_heap.push(p);
            median = p;
        }
        else if (counter % 2 == 0)
        {
            median =  (max_heap.top() + min_heap.top()) / 2;
            max_heap.pop();
            min_heap.pop();
        }
        else
        {
            if (p >= max_heap.top())
            {
                min_heap.push(p);
            }
            else
            {
                double tmp = max_heap.top();
                max_heap.pop();
                min_heap.push(tmp);
                max_heap.push(p);
            }
            median = max_heap.top();
        }
        cout << median << "\n";
        counter++;
    }
}
\end{lstlisting}
\end{solution}

\item  \textbf{BST}. Two elements of a binary search tree are swapped by mistake. Recover the tree without changing its structure. Implement with a constant space.

\begin{lstlisting}[language=C++]
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
void recoverTree(TreeNode *root)
{
	// TODO;
}
\end{lstlisting}

\begin{solution}
\begin{lstlisting}[language=C++]
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
TreeNode* first = NULL;
TreeNode* second = NULL;
TreeNode* prev = NULL;
void traverse(TreeNode* root)
{
    if(root == NULL)
    {
        return;
    }
    traverse(root->left);
    if(prev != NULL && root->val < prev->val && !first)
    {
        first = prev;
    }
    if(prev != NULL && root->val < prev->val && first)
    {
        second = root;
    }
    prev = root;
    traverse(root->right);
    
}
 
void recoverTree(TreeNode *root)
{
	traverse(root);
    if (first && second)
    {
        int temp = first->val;
        first->val = second->val;
        second->val = temp;
    }
	
}

\end{lstlisting}
\end{solution}

\item  \textbf{BST}. Input an integer array, then determine whether the array is the result of the post-order traversal of a binary search tree. If yes, return Yes; otherwise, return No. Suppose that any two numbers of the input array are different from each other. Show the implementation.

\begin{lstlisting}[language=C++]
// Input: an integer array
// Output: yes or no
bool verifySquenceOfBST(vector<int> sequence)
{
	// TODO;
}
\end{lstlisting}

\begin{solution}
$\ $ \\
Input of the function \textbf{root} is added only to specified the tree to traverse.
\begin{lstlisting}[language=C++]
// Input: an integer array
// Output: yes or no
bool verifySquenceOfBST(vector<int> squence)
{
    stack<int> s;
    int root = INT32_MAX;
    for (auto it = squence.rbegin(); it != squence.rend();it++)
    {
        if(*it > root)
        {
            return false;
        }
        while(!s.empty() && *it < s.top())
        {
            root = s.top();
            s.pop()
        }
        s.push(*it);
    }
    return true;
}
\end{lstlisting}
\end{solution}

\end{enumerate}

%========================================================================
\end{document}
